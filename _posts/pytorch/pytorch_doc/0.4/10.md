

# Torch

`torch`包含了多维张量的数据结构以及基于其上的多种数学运算。此外，它也提供了多种实用工具，其中一些可以更有效地对张量和任意类型进行序列化的工具。

它具有CUDA的对应实现，可以在`NVIDIA GPU`上进行张量运算(计算能力&gt;=3.0)。

## 张量 Tensors

```py
torch.is_tensor(obj)
```

判断是否为张量，如果是pytorch张量，则返回True

*   参数： obj (Object) – 判断对象

```py
torch.is_storage(obj)
```

判断是否为pytorch Storage，如何是，则返回True

*   参数： input (Object) – 判断对象

```py
torch.set_default_tensor_type(t)
```

```py
torch.numel(input)->int
```

返回`input` 张量中的元素个数

*   参数: input ([Tensor](https://pytorch.org/docs/tensors.html#torch.Tensor)) – 输入张量

例子:

```py
>>> a = torch.randn(1,2,3,4,5)
>>> torch.numel(a)
120
>>> a = torch.zeros(4,4)
>>> torch.numel(a)
16
```

```py
torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None)
```

设置打印选项。 完全参考自 [Numpy](https://docs.scipy.org/doc/numpy/reference/generated/numpy.set_printoptions.html)。

参数:

*   `precision` – 浮点数输出的精度位数 (默认为8 )
*   `threshold` – 阈值，触发汇总显示而不是完全显示(repr)的数组元素的总数 (默认为1000）
*   `edgeitems` – 每个维度的开头和结尾的摘要中的数组项目数(默认为3）。
*   `linewidth` – 用于插入行间隔的每行字符数(默认为80）。阈值矩阵将忽略此参数。
*   `profile` – pretty打印的完全默认值。 可以覆盖上述所有选项 (默认为short, full)

## 创建操作 Creation Ops

```py
torch.eye(n, m=None, out=None)
```

返回一个2维张量，对角线数字为1，其它位置为0

参数:

*   `n` (int) – 行数
*   `m` (int, 可选) – 列数.如果为None,则默认为_n_
*   `out` (Tensor,可选) - 输出张量

返回值: 2维张量，对角线为1，其它为0

返回类型： [Tensor](https://pytorch.org/docs/tensors.html#torch.Tensor)

例子:

```py
>>> torch.eye(3)
 1  0  0
 0  1  0
 0  0  1
[torch.FloatTensor of size 3x3]
```

```py
torch.from_numpy(ndarray) → Tensor
```

将`numpy.ndarray`转换为`Tensor`。 返回的张量tensor和numpy的ndarray共享同一内存空间。修改一个会导致另外一个也被修改。返回的张量不能调整大小。

例子:

```py
>>> a = numpy.array([1, 2, 3])
>>> t = torch.from_numpy(a)
>>> t
torch.LongTensor([1, 2, 3])
>>> t[0] = -1
>>> a
array([-1,  2,  3])
```

```py
torch.linspace(start, end, steps=100, out=None) → Tensor
```

返回start和end之间长度为`steps`的一维张量 参数:

*   `start (float)` – 点集的起始值
*   `end (float)` – 点集的最终值
*   `steps (int)` – 在`start` 和 `end`间的采样数,即返回多少个数
*   `out (Tensor, 可选的)` – 结果张量

例子:

```py
>>> torch.linspace(1.0,10.0,steps=5,out=None)

  1.0000
  3.2500
  5.5000
  7.7500
 10.0000
[torch.FloatTensor of size 5]

>>> torch.linspace(-10, 10, steps=5)

-10
 -5
  0
  5
 10
[torch.FloatTensor of size 5]

>>> torch.linspace(start=-10, end=10, steps=5)

-10
 -5
  0
  5
 10
[torch.FloatTensor of size 5]
```

```py
torch.logspace(start, end, steps=100, out=None) → Tensor
```

返回一个1维张量，包含在区间10^start和10^end上以对数刻度均匀间隔的`steps`个点。 输出1维张量的长度为`steps`。

参数:

*   `start (float)` – 该点集的起始点
*   `end (float)` – 该点集的最终值
*   `steps (int)` – 在`start` 和 `end`间生成的样本数
*   `out (Tensor, 可选)` – 结果张量

例子:

```py
>>> torch.logspace(start=-10, end=10, steps=5)

 1.0000e-10
 1.0000e-05
 1.0000e+00
 1.0000e+05
 1.0000e+10
[torch.FloatTensor of size 5]

>>> torch.logspace(start=0.1, end=1.0, steps=5)

  1.2589
  2.1135
  3.5481
  5.9566
 10.0000
[torch.FloatTensor of size 5]
```

```py
torch.ones(*sizes, out=None) → Tensor
```

返回一个全为1的张量，形状由可变参数`sizes`定义。

参数:

*   `sizes (int...)` – 整数序列，定义了输出形状,如：(5,5)，(2)
*   `out (Tensor, 可选)` – 结果张量

例子:

```py
>>> torch.ones(2, 3)

 1  1  1
 1  1  1
[torch.FloatTensor of size 2x3]

>>> torch.ones(5)

 1
 1
 1
 1
 1
[torch.FloatTensor of size 5]
```

```py
torch.rand(*sizes, out=None) → Tensor
```

返回一个张量，填充在[0,1]区间的一组均匀分布随机数。 Tensor的形状由变量`sizes`定义。

参数:

*   `sizes (int...)` – 整数序列，定义了输出形状
*   `out` (Tensor, 可选) - 结果张量

例子：

```py
>>> torch.rand(4)

 0.9193
 0.3347
 0.3232
 0.7715
[torch.FloatTensor of size 4]

>>> torch.rand(2, 3,out=None)

 0.5010  0.5140  0.0719
 0.1435  0.5636  0.0538
[torch.FloatTensor of size 2x3]
```

```py
torch.randn(*sizes, out=None) → Tensor
```

返回一个张量，包含了从正态分布(均值为0，方差为 1，即高斯白噪声)中抽取一组随机数。 Tensor的形状由变量`sizes`定义。

参数:

*   `sizes (int...)` – 整数序列，定义了输出形状
*   `out (Tensor, 可选) - 结果张量

例子：:

```py
>>> torch.randn(4)

-0.1145
 0.0094
-1.1717
 0.9846
[torch.FloatTensor of size 4]

>>> torch.randn(2, 3)

 1.4339  0.3351 -1.0999
 1.5458 -0.9643 -0.3558
[torch.FloatTensor of size 2x3]
```

```py
torch.randperm(n, out=None) → LongTensor
```

输入参数`n`，返回一个从`0` 到`n -1`的随机整数排列。

参数:

*   `n(int)` – 上限(独占),即最大值

例子：

```py
>>> torch.randperm(4)

 2
 1
 3
 0
[torch.LongTensor of size 4]
```

```py
torch.arange(start, end, step=1, out=None) → Tensor
```

返回一个1维张量，长度为floor((end−start)/step),floor代表向下取整。包含从`start`到`end`，以`step`为步长的一组序列值(默认步长为1)。

参数:

*   `start (float)` – 该点集的起始点
*   `end (float)` – 该点集的终止点
*   `step (float)` – 相邻点的间隔大小
*   `out (Tensor, 可选的)` – 结果张量

例子：

```py
>>> torch.arange(1, 4)

 1
 2
 3
[torch.FloatTensor of size 3]

>>> torch.arange(1, 2.5, 0.5)

 1.0000
 1.5000
 2.0000
[torch.FloatTensor of size 3]
```

```py
torch.range(start, end, step=1, out=None) → Tensor
```

返回一个1维张量，长度为floor((end−start)/step)+1，其中floor代表向下取整数。从`start`开始，`end`为结尾，以`step`为步长的一组值。 `step` 是两个值之间的间隔，即 Xi+1=Xi+step

参数:

*   start (float) – 该点集的起始点
*   end (float) – 该点集的最终值
*   step (int) – 相邻点之间的间隔大小
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> torch.range(1, 4)

 1
 2
 3
 4
[torch.FloatTensor of size 4]

>>> torch.range(1, 4, 0.5)

 1.0000
 1.5000
 2.0000
 2.5000
 3.0000
 3.5000
 4.0000
[torch.FloatTensor of size 7]
```

```py
torch.zeros(*sizes, out=None) → Tensor
```

返回一个全0的张量，形状由可变参数`sizes`定义。

参数:

*   sizes (int...) – 整数序列，定义了输出形状
*   out (Tensor, 可选) – 结果张量

例子：

```py
>>> torch.zeros(2, 3)

 0  0  0
 0  0  0
[torch.FloatTensor of size 2x3]

>>> torch.zeros(5)

 0
 0
 0
 0
 0
[torch.FloatTensor of size 5]
```

## 索引,切片,连接,变异操作

```py
torch.cat(seq, dim=0, out=None) → Tensor
```

在给定维度上对输入的张量序列`seq` 进行连接操作。

`torch.cat()`可以看做 `torch.split()` 和 `torch.chunk()`的逆运算。

`cat()`函数可以通过下面例子很好的的理解。

参数:

*   seq(Tensors的序列） - 可以是相同类型的Tensor的任何python序列。
*   dim(int，可选） - 张量连接的尺寸
*   out(Tensor，可选） - 输出参数

    例子：

    ```py
     &gt;&gt;&gt; x = torch.randn(2, 3)
    &gt;&gt;&gt; x

    0.5983 -0.0341  2.4918
    1.5981 -0.5265 -0.8735
    [torch.FloatTensor of size 2x3]
    ```

> &gt; &gt; torch.cat((x, x, x), 0)

0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 [torch.FloatTensor of size 6x3]

> &gt; &gt; torch.cat((x, x, x), 1)

0.5983 -0.0341 2.4918 0.5983 -0.0341 2.4918 0.5983 -0.0341 2.4918 1.5981 -0.5265 -0.8735 1.5981 -0.5265 -0.8735 1.5981 -0.5265 -0.8735 [torch.FloatTensor of size 2x9]

```py
 ```python
torch.chunk(tensor, chunks, dim=0)
```py

将张量沿着给定维度分解成的多个块。

参数:

*   tensor (Tensor) – 待分块的输入张量
*   chunks (int) – 分块的个数
*   dim (int) – 沿着此维度进行分块

```
torch.gather(input, dim, index, out=None) → Tensor
```py

沿给定轴`dim`，将输入索引张量`index`指定位置的值进行聚合。

对一个3维张量，输出可以定义为：

```
out[i][j][k] = tensor[index[i][j][k]][j][k]  # dim=0
out[i][j][k] = tensor[i][index[i][j][k]][k]  # dim=1
out[i][j][k] = tensor[i][j][index[i][j][k]]  # dim=3
```py

如果输入是一个n维张量((x0,x1...,xi−1,xi,xi+1,...,xn−1)和暗=我，然后指数必须是一个n维张量的大小(x0,x1,...,xi−1,y,xi+1,...,xn−1)其中y &gt; = 1和有同样大小的指标。

参数：

*   input(Tensor) - 源张量
*   dim(int) - 要索引的轴
*   index(LongTensor) - 要收集的元素的索引
*   out(Tensor，可选) - 目的张量

例子：

```
>>> t = torch.Tensor([[1,2],[3,4]])
>>> torch.gather(t, 1, torch.LongTensor([[0,0],[1,0]]))
 1  1
 4  3
[torch.FloatTensor of size 2x2]
```py

```
torch.index_select(input, dim, index, out=None) → Tensor
```py

返回一个新的张量，其索引input 张量沿尺寸 dim使用的条目中index这是一个LongTensor。

返回的Tensor具有与原始Tensor相同数量的尺寸。

注意： 返回的张量不与原始张量共享内存空间。

参数:

*   input (Tensor) – 输入张量
*   dim (int) – 索引的轴
*   index (LongTensor) – 包含索引下标的一维张量
*   out (Tensor, 可选的) – 目标张量

例子：

```
>>> x = torch.randn(3, 4)
>>> x

 1.2045  2.4084  0.4001  1.1372
 0.5596  1.5677  0.6219 -0.7954
 1.3635 -1.2313 -0.5414 -1.8478
[torch.FloatTensor of size 3x4]

>>> indices = torch.LongTensor([0, 2])
>>> torch.index_select(x, 0, indices)

 1.2045  2.4084  0.4001  1.1372
 1.3635 -1.2313 -0.5414 -1.8478
[torch.FloatTensor of size 2x4]

>>> torch.index_select(x, 1, indices)

 1.2045  0.4001
 0.5596  0.6219
 1.3635 -0.5414
[torch.FloatTensor of size 3x2]
```py

* * *

```
torch.masked_select(input, mask, out=None) → Tensor
```py

根据掩码张量`mask`中的二元值，取输入张量中的指定项( `mask`为一个 _ByteTensor_)，将取值返回到一个新的1D张量，

张量 `mask`须跟`input`张量有相同数量的元素数目，但形状或维度不需要相同。 注意： 返回的张量不与原始张量共享内存空间。

参数:

*   input (Tensor) – 输入张量
*   mask (ByteTensor) – 掩码张量，包含了二元索引值
*   out (Tensor, 可选的) – 目标张量

例子：

```
>>> x = torch.randn(3, 4)
>>> x

 1.2045  2.4084  0.4001  1.1372
 0.5596  1.5677  0.6219 -0.7954
 1.3635 -1.2313 -0.5414 -1.8478
[torch.FloatTensor of size 3x4]

>>> indices = torch.LongTensor([0, 2])
>>> torch.index_select(x, 0, indices)

 1.2045  2.4084  0.4001  1.1372
 1.3635 -1.2313 -0.5414 -1.8478
[torch.FloatTensor of size 2x4]

>>> torch.index_select(x, 1, indices)

 1.2045  0.4001
 0.5596  0.6219
 1.3635 -0.5414
[torch.FloatTensor of size 3x2]
```py

### torch.nonzero

```
torch.nonzero(input, out=None) → LongTensor
```py

返回一个包含输入`input`中非零元素索引的张量。输出张量中的每行包含输入中非零元素的索引。

如果输入`input`有`n`维，则输出的索引张量`output`的形状为 z x n, 这里 z 是输入张量`input`中所有非零元素的个数。

参数:

*   input (Tensor) – 源张量
*   out (LongTensor, 可选的) – 包含索引值的结果张量

例子：

```
>>> torch.nonzero(torch.Tensor([1, 1, 1, 0, 1]))

 0
 1
 2
 4
[torch.LongTensor of size 4x1]

>>> torch.nonzero(torch.Tensor([[0.6, 0.0, 0.0, 0.0],
...                             [0.0, 0.4, 0.0, 0.0],
...                             [0.0, 0.0, 1.2, 0.0],
...                             [0.0, 0.0, 0.0,-0.4]]))

 0  0
 1  1
 2  2
 3  3
[torch.LongTensor of size 4x2]
```py

### torch.split

```
torch.split(tensor, split_size, dim=0)
```py

将输入张量分割成相等形状的chunks(如果可分）。 如果沿指定维的张量形状大小不能被`split_size` 整分， 则最后一个分块会小于其它分块。

参数:

*   tensor (Tensor) – 待分割张量
*   split_size (int) – 单个分块的形状大小
*   dim (int) – 沿着此维进行分割

### torch.squeeze

```
torch.squeeze(input, dim=None, out=None)
```py

将输入张量形状中的`1` 去除并返回。 如果输入是形如\((A \times 1\times B \times 1 \times C \times 1 \times D) \)，那么输出形状就为： \((A \times B \times C \times D) \)

当给定`dim`时，那么挤压操作只在给定维度上。例如，输入形状为: \((A \times 1 \times B) \), `squeeze(input, 0)` 将会保持张量不变，只有用 `squeeze(input, 1)`，形状会变成 \( (A \times B )\)。

注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。

参数:

*   input (Tensor) – 输入张量
*   dim (int, 可选的) – 如果给定，则`input`只会在给定维度挤压
*   out (Tensor, 可选的) – 输出张量

例子：

```
>>> x = torch.zeros(2,1,2,1,2)
>>> x.size()
(2L, 1L, 2L, 1L, 2L)
>>> y = torch.squeeze(x)
>>> y.size()
(2L, 2L, 2L)
>>> y = torch.squeeze(x, 0)
>>> y.size()
(2L, 1L, 2L, 1L, 2L)
>>> y = torch.squeeze(x, 1)
>>> y.size()
(2L, 2L, 1L, 2L)
```py

### torch.stack[[source]](https://pytorch.org/docs/_modules/torch/functional.html#stack)

```
torch.stack(sequence, dim=0)
```py

沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。

参数:

*   sqequence (Sequence) – 待连接的张量序列
*   dim (int) – 插入的维度。必须介于 0 与 待连接的张量序列数之间。

### torch.t

```
torch.t(input, out=None) → Tensor
```py

输入一个矩阵(2维张量），并转置0, 1维。 可以被视为函数`transpose(input, 0, 1)`的简写函数。

参数:

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 结果张量

    ```
     &gt;&gt;&gt; x = torch.randn(2, 3)
    &gt;&gt;&gt; x

    0.4834  0.6907  1.3417
    -0.1300  0.5295  0.2321
    [torch.FloatTensor of size 2x3]
    ```py

> &gt; &gt; torch.t(x)

0.4834 -0.1300 0.6907 0.5295 1.3417 0.2321 [torch.FloatTensor of size 3x2]

```
 ### torch.transpose
```pypython
torch.transpose(input, dim0, dim1, out=None) → Tensor
```

返回输入矩阵`input`的转置。交换维度`dim0`和`dim1`。 输出张量与输入张量共享内存，所以改变其中一个会导致另外一个也被修改。

参数:

*   input (Tensor) – 输入张量
*   dim0 (int) – 转置的第一维
*   dim1 (int) – 转置的第二维

```py
>>> x = torch.randn(2, 3)
>>> x

 0.5983 -0.0341  2.4918
 1.5981 -0.5265 -0.8735
[torch.FloatTensor of size 2x3]

>>> torch.transpose(x, 0, 1)

 0.5983  1.5981
-0.0341 -0.5265
 2.4918 -0.8735
[torch.FloatTensor of size 3x2]
```

### torch.unbind

```py
torch.unbind(tensor, dim=0)[source]
```

移除指定维后，返回一个元组，包含了沿着指定维切片后的各个切片

参数:

*   tensor (Tensor) – 输入张量
*   dim (int) – 删除的维度

### torch.unsqueeze

```py
torch.unsqueeze(input, dim, out=None)
```

返回一个新的张量，对输入的制定位置插入维度 1

注意： 返回张量与输入张量共享内存，所以改变其中一个的内容会改变另一个。

如果`dim`为负，则将会被转化\( dim+input.dim()+1 \)

参数:

*   tensor (Tensor) – 输入张量
*   dim (int) – 插入维度的索引
*   out (Tensor, 可选的) – 结果张量

```py
>>> x = torch.Tensor([1, 2, 3, 4])
>>> torch.unsqueeze(x, 0)
 1  2  3  4
[torch.FloatTensor of size 1x4]
>>> torch.unsqueeze(x, 1)
 1
 2
 3
 4
[torch.FloatTensor of size 4x1]
```

## 随机抽样 Random sampling

### torch.manual_seed

```py
torch.manual_seed(seed)
```

设定生成随机数的种子，并返回一个 _torch._C.Generator_ 对象.

参数: seed (int or long) – 种子.

### torch.initial_seed

```py
torch.initial_seed()
```

返回生成随机数的原始种子值(python long）。

### torch.get_rng_state

```py
torch.get_rng_state()[source]
```

返回随机生成器状态(_ByteTensor_)

### torch.set_rng_state

```py
torch.set_rng_state(new_state)[source]
```

设定随机生成器状态 参数: new_state (torch.ByteTensor) – 期望的状态

### torch.default_generator

```py
torch.default_generator = <torch._C.Generator object>
```

### torch.bernoulli

```py
torch.bernoulli(input, out=None) → Tensor
```

从伯努利分布中抽取二元随机数(0 或者 1)。

输入张量须包含用于抽取上述二元随机值的概率。 因此，输入中的所有值都必须在［0,1］区间，即 \( 0&lt;=input_i&lt;=1 \)

输出张量的第_`i`_个元素值， 将会以输入张量的第_`i`_个概率值等于`1`。

返回值将会是与输入相同大小的张量，每个值为0或者1 参数:

*   input (Tensor) – 输入为伯努利分布的概率值
*   out (Tensor, 可选的) – 输出张量(可选)

例子：

```py
>>> a = torch.Tensor(3, 3).uniform_(0, 1) # generate a uniform random matrix with range [0, 1]
>>> a

 0.7544  0.8140  0.9842
 0.5282  0.0595  0.6445
 0.1925  0.9553  0.9732
[torch.FloatTensor of size 3x3]

>>> torch.bernoulli(a)

 1  1  1
 0  0  1
 0  1  1
[torch.FloatTensor of size 3x3]

>>> a = torch.ones(3, 3) # probability of drawing "1" is 1
>>> torch.bernoulli(a)

 1  1  1
 1  1  1
 1  1  1
[torch.FloatTensor of size 3x3]

>>> a = torch.zeros(3, 3) # probability of drawing "1" is 0
>>> torch.bernoulli(a)

 0  0  0
 0  0  0
 0  0  0
[torch.FloatTensor of size 3x3]
```

### torch.multinomial

```py
torch.multinomial(input, num_samples,replacement=False, out=None) → LongTensor
```

返回一个张量，每行包含从`input`相应行中定义的多项分布中抽取的`num_samples`个样本。

当抽取样本时，依次从左到右排列(第一个样本对应第一列)。

如果输入`input`是一个向量，输出`out`也是一个相同长度`num_samples`的向量。如果输入`input`是有 \(m \)行的矩阵，输出`out`是形如\( m \times n \)的矩阵。

如果参数`replacement` 为 _True_, 则样本抽取可以重复。否则，一个样本在每行不能被重复抽取。

参数`num_samples`必须小于`input`长度(即，`input`的列数，如果是`input`是一个矩阵)。

参数:

*   input (Tensor) – 包含概率值的张量
*   num_samples (int) – 抽取的样本数
*   replacement (bool, 可选的) – 布尔值，决定是否能重复抽取
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> weights = torch.Tensor([0, 10, 3, 0]) # create a Tensor of weights
>>> torch.multinomial(weights, 4)

 1
 2
 0
 0
[torch.LongTensor of size 4]

>>> torch.multinomial(weights, 4, replacement=True)

 1
 2
 1
 2
[torch.LongTensor of size 4]
```

### torch.normal()

```py
torch.normal(means, std, out=None)
```

返回一个张量，包含从给定参数`means`,`std`的离散正态分布中抽取随机数。 均值`means`是一个张量，包含每个输出元素相关的正态分布的均值。 `std`是一个张量，包含每个输出元素相关的正态分布的标准差。 均值和标准差的形状不须匹配，但每个张量的元素个数须相同。

参数:

*   means (Tensor) – 均值
*   std (Tensor) – 标准差
*   out (Tensor) – 可选的输出张量

```py
torch.normal(means=torch.arange(1, 11), std=torch.arange(1, 0, -0.1))

 1.5104
 1.6955
 2.4895
 4.9185
 4.9895
 6.9155
 7.3683
 8.1836
 8.7164
 9.8916
[torch.FloatTensor of size 10]
```

```py
torch.normal(mean=0.0, std, out=None)
```

与上面函数类似，所有抽取的样本共享均值。

参数:

*   means (Tensor,可选的) – 所有分布均值
*   std (Tensor) – 每个元素的标准差
*   out (Tensor) – 可选的输出张量

例子:

```py
>>> torch.normal(mean=0.5, std=torch.arange(1, 6))

  0.5723
  0.0871
 -0.3783
 -2.5689
 10.7893
[torch.FloatTensor of size 5] 
```

```py
torch.normal(means, std=1.0, out=None)
```

与上面函数类似，所有抽取的样本共享标准差。

参数:

*   means (Tensor) – 每个元素的均值
*   std (float, 可选的) – 所有分布的标准差
*   out (Tensor) – 可选的输出张量

例子:

```py
>>> torch.normal(means=torch.arange(1, 6))

 1.1681
 2.8884
 3.7718
 2.5616
 4.2500
[torch.FloatTensor of size 5]
```

## 序列化 Serialization

### torch.saves[[source]](https://pytorch.org/docs/_modules/torch/serialization.html#save)

```py
torch.save(obj, f, pickle_module=<module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'>, pickle_protocol=2)
```

保存一个对象到一个硬盘文件上 参考: [Recommended approach for saving a model](https://pytorch.org/docs/notes/serialization.html#recommend-saving-models) 参数：

*   obj – 保存对象
*   f － 类文件对象 (返回文件描述符)或一个保存文件名的字符串
*   pickle_module – 用于pickling元数据和对象的模块
*   pickle_protocol – 指定pickle protocal 可以覆盖默认参数

### torch.load[[source]](https://pytorch.org/docs/_modules/torch/serialization.html#load)

```py
torch.load(f, map_location=None, pickle_module=<module 'pickle' from '/home/jenkins/miniconda/lib/python3.5/pickle.py'>)
```

从磁盘文件中读取一个通过`torch.save()`保存的对象。 `torch.load()` 可通过参数`map_location` 动态地进行内存重映射，使其能从不动设备中读取文件。一般调用时，需两个参数: storage 和 location tag. 返回不同地址中的storage，或着返回None (此时地址可以通过默认方法进行解析). 如果这个参数是字典的话，意味着其是从文件的地址标记到当前系统的地址标记的映射。 默认情况下， location tags中 "cpu"对应host tensors，‘cuda:device_id’ (e.g. ‘cuda:2’) 对应cuda tensors。 用户可以通过register_package进行扩展，使用自己定义的标记和反序列化方法。

参数:

*   f – 类文件对象 (返回文件描述符)或一个保存文件名的字符串
*   map_location – 一个函数或字典规定如何remap存储位置
*   pickle_module – 用于unpickling元数据和对象的模块 (必须匹配序列化文件时的pickle_module )

例子:

```py
>>> torch.load('tensors.pt')
# Load all tensors onto the CPU
>>> torch.load('tensors.pt', map_location=lambda storage, loc: storage)
# Map tensors from GPU 1 to GPU 0
>>> torch.load('tensors.pt', map_location={'cuda:1':'cuda:0'})
```

## 并行化 Parallelism

### torch.get_num_threads

```py
torch.get_num_threads() → int
```

获得用于并行化CPU操作的OpenMP线程数

### torch.set_num_threads

```py
torch.set_num_threads(int)
```

设定用于并行化CPU操作的OpenMP线程数

# 数学操作Math operations

## Pointwise Ops

### torch.abs

```py
torch.abs(input, out=None) → Tensor
```

计算输入张量的每个元素绝对值

例子：

```py
>>> torch.abs(torch.FloatTensor([-1, -2, 3]))
FloatTensor([1, 2, 3])
```

### torch.acos(input, out=None) → Tensor

```py
torch.acos(input, out=None) → Tensor
```

返回一个新张量，包含输入张量每个元素的反余弦。 参数：

*   input (Tensor) – 输入张量
*   out ([Tensor](https://pytorch.org/docs/tensors.html#torch.Tensor), 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(4)
>>> a

-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.acos(a)
 2.2608
 1.2956
 1.1075
    nan
[torch.FloatTensor of size 4]
```

### torch.add()

```py
torch.add(input, value, out=None)
```

对输入张量`input`逐元素加上标量值`value`，并返回结果到一个新的张量`out`，即 \( out = tensor + value \)。

如果输入`input`是FloatTensor or DoubleTensor类型，则`value` 必须为实数，否则须为整数。

*   input (Tensor) – 输入张量
*   value (Number) – 添加到输入每个元素的数
*   out (Tensor, 可选的) – 结果张量

```py
>>> a = torch.randn(4)
>>> a

 0.4050
-1.2227
 1.8688
-0.4185
[torch.FloatTensor of size 4]

>>> torch.add(a, 20)

 20.4050
 18.7773
 21.8688
 19.5815
[torch.FloatTensor of size 4]
```

```py
torch.add(input, value=1, other, out=None)
```

`other` 张量的每个元素乘以一个标量值`value`，并加到`iput` 张量上。返回结果到输出张量`out`。即，\( out=input+(other∗value ) \)

两个张量 `input` and `other`的尺寸不需要匹配，但元素总数必须一样。

如果`other`是FloatTensor or DoubleTensor类型，则`value` 必须为实数，否则须为整数。

参数:

*   input (Tensor) – 第一个输入张量
*   value (Number) – 用于第二个张量的尺寸因子
*   other (Tensor) – 第二个输入张量
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> import torch
>>> a = torch.randn(4)
>>> a

-0.9310
 2.0330
 0.0852
-0.2941
[torch.FloatTensor of size 4]

>>> b = torch.randn(2, 2)
>>> b

 1.0663  0.2544
-0.1513  0.0749
[torch.FloatTensor of size 2x2]

>>> torch.add(a, 10, b)
 9.7322
 4.5770
-1.4279
 0.4552
[torch.FloatTensor of size 4]
```

### torch.addcdiv

```py
torch.addcdiv(tensor, value=1, tensor1, tensor2, out=None) → Tensor
```

对`tensor2`对`tensor1`逐元素相除，然后乘以标量值`value` 并加到`tensor`。

张量的形状不需要匹配，但元素数量必须一致。

如果输入是FloatTensor or DoubleTensor类型，则`value` 必须为实数，否则须为整数。

参数：

*   tensor (Tensor) – 张量，对 tensor1 ./ tensor 进行相加
*   value (Number, 可选的) – 标量，对 tensor1 ./ tensor2 进行相乘
*   tensor1 (Tensor) – 张量，作为被除数(分子)
*   tensor2 (Tensor) –张量，作为除数(分母)
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> t = torch.randn(2, 3)
>>> t1 = torch.randn(1, 6)
>>> t2 = torch.randn(6, 1)
>>> torch.addcdiv(t, 0.1, t1, t2)

 0.0122 -0.0188 -0.2354
 0.7396 -1.5721  1.2878
[torch.FloatTensor of size 2x3]
```

### torch.addcmul

```py
torch.addcmul(tensor, value=1, tensor1, tensor2, out=None) → Tensor
```

用`tensor2`对`tensor1`逐元素相乘，并对结果乘以标量值`value`然后加到`tensor`。 张量的形状不需要匹配，但元素数量必须一致。 如果输入是FloatTensor or DoubleTensor类型，则`value` 必须为实数，否则须为整数。

参数：

*   tensor (Tensor) – 张量，对tensor1 ./ tensor 进行相加
*   value (Number, 可选的) – 标量，对 tensor1 . tensor2 进行相乘
*   tensor1 (Tensor) – 张量，作为乘子1
*   tensor2 (Tensor) –张量，作为乘子2
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> t = torch.randn(2, 3)
>>> t1 = torch.randn(1, 6)
>>> t2 = torch.randn(6, 1)
>>> torch.addcmul(t, 0.1, t1, t2)

 0.0122 -0.0188 -0.2354
 0.7396 -1.5721  1.2878
[torch.FloatTensor of size 2x3]
```

### torch.asin

```py
torch.asin(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的反正弦函数

参数：

*   tensor (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.asin(a)
-0.6900
 0.2752
 0.4633
    nan
[torch.FloatTensor of size 4]
```

### torch.atan

```py
torch.atan(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的反正切函数

参数：

*   tensor (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.atan(a)
-0.5669
 0.2653
 0.4203
 0.9196
[torch.FloatTensor of size 4]
```

### torch.atan2

```py
torch.atan2(input1, input2, out=None) → Tensor
```

返回一个新张量，包含两个输入张量`input1`和`input2`的反正切函数

参数：

*   input1 (Tensor) – 第一个输入张量
*   input2 (Tensor) – 第二个输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.atan2(a, torch.randn(4))
-2.4167
 2.9755
 0.9363
 1.6613
[torch.FloatTensor of size 4]
```

### torch.ceil

```py
torch.ceil(input, out=None) → Tensor
```

天井函数，对输入`input`张量每个元素向上取整, 即取不小于每个元素的最小整数，并返回结果到输出。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.3869
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]

>>> torch.ceil(a)

 2
 1
-0
-0
[torch.FloatTensor of size 4]
```

### torch.clamp

```py
torch.clamp(input, min, max, out=None) → Tensor
```

将输入`input`张量每个元素的夹紧到区间 \([min, max] \)，并返回结果到一个新张量。

操作定义如下：

```py
 | min, if x_i < min
y_i = | x_i, if min <= x_i <= max
      | max, if x_i > max
```

如果输入是FloatTensor or DoubleTensor类型，则参数`min` `max` 必须为实数，否则须为整数。

参数：

*   input (Tensor) – 输入张量
*   min (Number) – 限制范围下限
*   max (Number) – 限制范围上限
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.3869
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]

>>> torch.clamp(a, min=-0.5, max=0.5)

 0.5000
 0.3912
-0.5000
-0.5000
[torch.FloatTensor of size 4]
```

```py
torch.clamp(input, *, min, out=None) → Tensor
```

将输入`input`张量每个元素的限制到不小于`min` ，并返回结果到一个新张量。

如果输入是FloatTensor or DoubleTensor类型，则参数 `value` 必须为实数，否则须为整数。

参数：

*   input (Tensor) – 输入张量
*   value (Number) – 限制范围下限
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.3869
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]

>>> torch.clamp(a, min=0.5)

 1.3869
 0.5000
 0.5000
 0.5000
[torch.FloatTensor of size 4]
```

```py
torch.clamp(input, *, max, out=None) → Tensor
```

将输入`input`张量每个元素的限制到不大于`max` ，并返回结果到一个新张量。

如果输入是FloatTensor or DoubleTensor类型，则参数 `value` 必须为实数，否则须为整数。

参数：

*   input (Tensor) – 输入张量
*   value (Number) – 限制范围上限
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.3869
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]

>>> torch.clamp(a, max=0.5)

 0.5000
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]
```

### torch.cos

```py
torch.cos(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的余弦。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.cos(a)
 0.8041
 0.9633
 0.9018
 0.2557
[torch.FloatTensor of size 4]
```

### torch.cosh

```py
torch.cosh(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的双曲余弦。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.cosh(a)
 1.2095
 1.0372
 1.1015
 1.9917
[torch.FloatTensor of size 4]
```

### torch.div()

```py
torch.div(input, value, out=None)
```

将`input`逐元素除以标量值`value`，并返回结果到输出张量`out`。 即 \( out=tensor/value \)

如果输入是FloatTensor or DoubleTensor类型，则参数 `value` 必须为实数，否则须为整数。

参数：

*   input (Tensor) – 输入张量
*   value (Number) – 除数
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(5)
>>> a

-0.6147
-1.1237
-0.1604
-0.6853
 0.1063
[torch.FloatTensor of size 5]

>>> torch.div(a, 0.5)

-1.2294
-2.2474
-0.3208
-1.3706
 0.2126
[torch.FloatTensor of size 5]
```

```py
torch.div(input, other, out=None)
```

两张量`input`和`other`逐元素相除，并将结果返回到输出。即， \( out_i= input_i / other_i \)

两张量形状不须匹配，但元素数须一致。

注意：当形状不匹配时，`input`的形状作为输出张量的形状。

参数：

*   input (Tensor) – 张量(分子)
*   other (Tensor) – 张量(分母)
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4,4)
>>> a

-0.1810  0.4017  0.2863 -0.1013
 0.6183  2.0696  0.9012 -1.5933
 0.5679  0.4743 -0.0117 -0.1266
-0.1213  0.9629  0.2682  1.5968
[torch.FloatTensor of size 4x4]

>>> b = torch.randn(8, 2)
>>> b

 0.8774  0.7650
 0.8866  1.4805
-0.6490  1.1172
 1.4259 -0.8146
 1.4633 -0.1228
 0.4643 -0.6029
 0.3492  1.5270
 1.6103 -0.6291
[torch.FloatTensor of size 8x2]

>>> torch.div(a, b)

-0.2062  0.5251  0.3229 -0.0684
-0.9528  1.8525  0.6320  1.9559
 0.3881 -3.8625 -0.0253  0.2099
-0.3473  0.6306  0.1666 -2.5381
[torch.FloatTensor of size 4x4]
```

### torch.exp

```py
torch.exp(tensor, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的指数。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

    ```py
    &gt;&gt;&gt; torch.exp(torch.Tensor([0, math.log(2)]))
    torch.FloatTensor([1, 2])
    ```

    ### torch.floor

```py
torch.floor(input, out=None) → Tensor
```

床函数: 返回一个新张量，包含输入`input`张量每个元素的floor，即不小于元素的最大整数。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.3869
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]

>>> torch.floor(a)

 1
 0
-1
-1
[torch.FloatTensor of size 4]
```

### torch.fmod

```py
torch.fmod(input, divisor, out=None) → Tensor
```

计算除法余数。 除数与被除数可能同时含有整数和浮点数。此时，余数的正负与被除数相同。

参数：

*   input (Tensor) – 被除数
*   divisor (Tensor or float) – 除数，一个数或与被除数相同类型的张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> torch.fmod(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)
torch.FloatTensor([-1, -0, -1, 1, 0, 1])
>>> torch.fmod(torch.Tensor([1, 2, 3, 4, 5]), 1.5)
torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])
```

参考: [`torch.remainder()`](https://pytorch.org/docs/torch.html#torch.remainder), 计算逐元素余数， 相当于python 中的 % 操作符。

### torch.frac

```py
torch.frac(tensor, out=None) → Tensor
```

返回每个元素的分数部分。

例子：

```py
>>> torch.frac(torch.Tensor([1, 2.5, -3.2])
torch.FloatTensor([0, 0.5, -0.2])
```

### torch.lerp

```py
torch.lerp(start, end, weight, out=None)
```

对两个张量以`start`，`end`做线性插值， 将结果返回到输出张量。

即，\( out_i=start_i+weight∗(end_i−start_i) \)

参数：

*   start (Tensor) – 起始点张量
*   end (Tensor) – 终止点张量
*   weight (float) – 插值公式的weight
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> start = torch.arange(1, 5)
>>> end = torch.Tensor(4).fill_(10)
>>> start

 1
 2
 3
 4
[torch.FloatTensor of size 4]

>>> end

 10
 10
 10
 10
[torch.FloatTensor of size 4]

>>> torch.lerp(start, end, 0.5)

 5.5000
 6.0000
 6.5000
 7.0000
[torch.FloatTensor of size 4] 
```

### torch.log

```py
torch.log(input, out=None) → Tensor
```

计算`input` 的自然对数

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(5)
>>> a

-0.4183
 0.3722
-0.3091
 0.4149
 0.5857
[torch.FloatTensor of size 5]

>>> torch.log(a)

    nan
-0.9883
    nan
-0.8797
-0.5349
[torch.FloatTensor of size 5]
```

### torch.log1p

```py
torch.log1p(input, out=None) → Tensor
```

计算 \( input +1 \)的自然对数 \( y_i=log(x_i+1) \)

注意：对值比较小的输入，此函数比`torch.log()`更准确。

如果输入是FloatTensor or DoubleTensor类型，则`value` 必须为实数，否则须为整数。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(5)
>>> a

-0.4183
 0.3722
-0.3091
 0.4149
 0.5857
[torch.FloatTensor of size 5]

>>> torch.log1p(a)

-0.5418
 0.3164
-0.3697
 0.3471
 0.4611
[torch.FloatTensor of size 5]
```

### torch.mul

```py
torch.mul(input, value, out=None)
```

用标量值`value`乘以输入`input`的每个元素，并返回一个新的结果张量。 \( out=tensor ∗ value \)

如果输入是FloatTensor or DoubleTensor类型，则`value` 必须为实数，否则须为整数。

参数：

*   input (Tensor) – 输入张量
*   value (Number) – 乘到每个元素的数
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(3)
>>> a

-0.9374
-0.5254
-0.6069
[torch.FloatTensor of size 3]

>>> torch.mul(a, 100)

-93.7411
-52.5374
-60.6908
[torch.FloatTensor of size 3]
```

```py
torch.mul(input, other, out=None)
```

两个张量`input`,`other`按元素进行相乘，并返回到输出张量。即计算\( out_i=input_i ∗ other_i \)

两计算张量形状不须匹配，但总元素数须一致。

参数：

*   input (Tensor) – 第一个相乘张量
*   other (Tensor) – 第二个相乘张量
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(4,4)
>>> a

-0.7280  0.0598 -1.4327 -0.5825
-0.1427 -0.0690  0.0821 -0.3270
-0.9241  0.5110  0.4070 -1.1188
-0.8308  0.7426 -0.6240 -1.1582
[torch.FloatTensor of size 4x4]

>>> b = torch.randn(2, 8)
>>> b

 0.0430 -1.0775  0.6015  1.1647 -0.6549  0.0308 -0.1670  1.0742
-1.2593  0.0292 -0.0849  0.4530  1.2404 -0.4659 -0.1840  0.5974
[torch.FloatTensor of size 2x8]

>>> torch.mul(a, b)

-0.0313 -0.0645 -0.8618 -0.6784
 0.0934 -0.0021 -0.0137 -0.3513
 1.1638  0.0149 -0.0346 -0.5068
-1.0304 -0.3460  0.1148 -0.6919
[torch.FloatTensor of size 4x4]
```

### torch.neg

```py
torch.neg(input, out=None) → Tensor
```

返回一个新张量，包含输入`input` 张量按元素取负。 即， \( out=−1∗input \)

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(5)
>>> a

-0.4430
 1.1690
-0.8836
-0.4565
 0.2968
[torch.FloatTensor of size 5]

>>> torch.neg(a)

 0.4430
-1.1690
 0.8836
 0.4565
-0.2968
[torch.FloatTensor of size 5]
```

### torch.pow

```py
torch.pow(input, exponent, out=None)
```

对输入`input`的按元素求`exponent`次幂值，并返回结果张量。 幂值`exponent` 可以为单一 `float` 数或者与`input`相同元素数的张量。

当幂值为标量时，执行操作： $$ out_i=x^{exponent} $$

当幂值为张量时，执行操作： $$ out_i=x^{exponent_i} $$

参数：

*   input (Tensor) – 输入张量
*   exponent (float or Tensor) – 幂值
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

-0.5274
-0.8232
-2.1128
 1.7558
[torch.FloatTensor of size 4]

>>> torch.pow(a, 2)

 0.2781
 0.6776
 4.4640
 3.0829
[torch.FloatTensor of size 4]

>>> exp = torch.arange(1, 5)
>>> a = torch.arange(1, 5)
>>> a

 1
 2
 3
 4
[torch.FloatTensor of size 4]

>>> exp

 1
 2
 3
 4
[torch.FloatTensor of size 4]

>>> torch.pow(a, exp)

   1
   4
  27
 256
[torch.FloatTensor of size 4]
```

```py
torch.pow(base, input, out=None)
```

`base` 为标量浮点值,`input`为张量， 返回的输出张量 `out` 与输入张量相同形状。

执行操作为: $$ out_i=base^{input_i} $$

参数：

*   base (float) – 标量值，指数的底
*   input ( Tensor) – 幂值
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> exp = torch.arange(1, 5)
>>> base = 2
>>> torch.pow(base, exp)

  2
  4
  8
 16
[torch.FloatTensor of size 4]
```

### torch.reciprocal

```py
torch.reciprocal(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的倒数，即 1.0/x。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.3869
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]

>>> torch.reciprocal(a)

 0.7210
 2.5565
-1.1583
-1.8289
[torch.FloatTensor of size 4]
```

### torch.remainder

```py
torch.remainder(input, divisor, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的除法余数。 除数与被除数可能同时包含整数或浮点数。余数与除数有相同的符号。

参数：

*   input (Tensor) – 被除数
*   divisor (Tensor or float) – 除数，一个数或者与除数相同大小的张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> torch.remainder(torch.Tensor([-3, -2, -1, 1, 2, 3]), 2)
torch.FloatTensor([1, 0, 1, 1, 0, 1])
>>> torch.remainder(torch.Tensor([1, 2, 3, 4, 5]), 1.5)
torch.FloatTensor([1.0, 0.5, 0.0, 1.0, 0.5])
```

### torch.round

```py
torch.round(input, out=None) → Tensor
```

返回一个新张量，将输入`input`张量每个元素舍入到最近的整数。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.2290
 1.3409
-0.5662
-0.0899
[torch.FloatTensor of size 4]

>>> torch.round(a)

 1
 1
-1
-0
[torch.FloatTensor of size 4]
```

### torch.rsqrt

```py
torch.rsqrt(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的平方根倒数。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.2290
 1.3409
-0.5662
-0.0899
[torch.FloatTensor of size 4]

>>> torch.rsqrt(a)

 0.9020
 0.8636
    nan
    nan
[torch.FloatTensor of size 4]
```

### torch.sigmoid

```py
torch.sigmoid(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的sigmoid值。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

-0.4972
 1.3512
 0.1056
-0.2650
[torch.FloatTensor of size 4]

>>> torch.sigmoid(a)

 0.3782
 0.7943
 0.5264
 0.4341
[torch.FloatTensor of size 4]
```

### torch.sign

```py
torch.sign(input, out=None) → Tensor
```

符号函数：返回一个新张量，包含输入`input`张量每个元素的正负。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.sign(a)

-1
 1
 1
 1
[torch.FloatTensor of size 4]
```

### torch.sin

```py
torch.sin(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的正弦。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.sin(a)
-0.5944
 0.2684
 0.4322
 0.9667
[torch.FloatTensor of size 4]
```

### torch.sinh

```py
torch.sinh(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的双曲正弦。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.sinh(a)
-0.6804
 0.2751
 0.4619
 1.7225
[torch.FloatTensor of size 4]
```

### torch.sqrt

```py
torch.sqrt(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的平方根。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

 1.2290
 1.3409
-0.5662
-0.0899
[torch.FloatTensor of size 4]

>>> torch.sqrt(a)

 1.1086
 1.1580
    nan
    nan
[torch.FloatTensor of size 4]
```

### torch.tan

```py
torch.tan(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的正切。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.tan(a)
-0.7392
 0.2786
 0.4792
 3.7801
[torch.FloatTensor of size 4]
```

### torch.tanh

```py
torch.tanh(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的双曲正切。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a
-0.6366
 0.2718
 0.4469
 1.3122
[torch.FloatTensor of size 4]

>>> torch.tanh(a)
-0.5625
 0.2653
 0.4193
 0.8648
[torch.FloatTensor of size 4]
```

### torch.trunc

```py
torch.trunc(input, out=None) → Tensor
```

返回一个新张量，包含输入`input`张量每个元素的截断值(标量x的截断值是最接近其的整数，其比x更接近零。简而言之，有符号数的小数部分被舍弃)。

参数：

*   input (Tensor) – 输入张量
*   out (Tensor, 可选的) – 输出张量

例子：

```py
>>> a = torch.randn(4)
>>> a

-0.4972
 1.3512
 0.1056
-0.2650
[torch.FloatTensor of size 4]

>>> torch.trunc(a)

-0
 1
 0
-0
[torch.FloatTensor of size 4]
```

## Reduction Ops

### torch.cumprod

```py
torch.cumprod(input, dim, out=None) → Tensor
```

返回输入沿指定维度的累积积。例如，如果输入是一个N 元向量，则结果也是一个N 元向量，第`i` 个输出元素值为\( yi=x1∗x2∗x3∗...∗xi \)

参数：

*   input (Tensor) – 输入张量
*   dim (int) – 累积积操作的维度
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(10)
>>> a

 1.1148
 1.8423
 1.4143
-0.4403
 1.2859
-1.2514
-0.4748
 1.1735
-1.6332
-0.4272
[torch.FloatTensor of size 10]

>>> torch.cumprod(a, dim=0)

 1.1148
 2.0537
 2.9045
-1.2788
-1.6444
 2.0578
-0.9770
-1.1466
 1.8726
-0.8000
[torch.FloatTensor of size 10]

>>> a[5] = 0.0
>>> torch.cumprod(a, dim=0)

 1.1148
 2.0537
 2.9045
-1.2788
-1.6444
-0.0000
 0.0000
 0.0000
-0.0000
 0.0000
[torch.FloatTensor of size 10]
```

### torch.cumsum

```py
torch.cumsum(input, dim, out=None) → Tensor
```

返回输入沿指定维度的累积和。例如，如果输入是一个N元向量，则结果也是一个N元向量，第`i` 个输出元素值为 \( yi=x1+x2+x3+...+xi\)

参数：

*   input (Tensor) – 输入张量
*   dim (int) – 累积和操作的维度
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(10)
>>> a

-0.6039
-0.2214
-0.3705
-0.0169
 1.3415
-0.1230
 0.9719
 0.6081
-0.1286
 1.0947
[torch.FloatTensor of size 10]

>>> torch.cumsum(a, dim=0)

-0.6039
-0.8253
-1.1958
-1.2127
 0.1288
 0.0058
 0.9777
 1.5858
 1.4572
 2.5519
[torch.FloatTensor of size 10]
```

### torch.dist

```py
torch.dist(input, other, p=2, out=None) → Tensor
```

返回 (`input` - `other`) 的 `p`范数 。

参数：

*   input (Tensor) – 输入张量
*   other (Tensor) – 右侧输入张量
*   p (float, 可选的) – 所计算的范数
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> x = torch.randn(4)
>>> x

 0.2505
-0.4571
-0.3733
 0.7807
[torch.FloatTensor of size 4]

>>> y = torch.randn(4)
>>> y

 0.7782
-0.5185
 1.4106
-2.4063
[torch.FloatTensor of size 4]

>>> torch.dist(x, y, 3.5)
3.302832063224223
>>> torch.dist(x, y, 3)
3.3677282206393286
>>> torch.dist(x, y, 0)
inf
>>> torch.dist(x, y, 1)
5.560028076171875
```

### torch.mean

```py
torch.mean(input) → float
```

返回输入张量所有元素的均值。

参数： input (Tensor) – 输入张量

例子：

```py
>>> a = torch.randn(1, 3)
>>> a

-0.2946 -0.9143  2.1809
[torch.FloatTensor of size 1x3]

>>> torch.mean(a)
0.32398951053619385
```

```py
torch.mean(input, dim, out=None) → Tensor
```

返回输入张量给定维度`dim`上每行的均值。

输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量
*   dim (int) – the dimension to reduce
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(4, 4)
>>> a

-1.2738 -0.3058  0.1230 -1.9615
 0.8771 -0.5430 -0.9233  0.9879
 1.4107  0.0317 -0.6823  0.2255
-1.3854  0.4953 -0.2160  0.2435
[torch.FloatTensor of size 4x4]

>>> torch.mean(a, 1)

-0.8545
 0.0997
 0.2464
-0.2157
[torch.FloatTensor of size 4x1]
```

### torch.median

```py
torch.median(input, dim=-1, values=None, indices=None) -> (Tensor, LongTensor)
```

返回输入张量给定维度每行的中位数，同时返回一个包含中位数的索引的`LongTensor`。

`dim`值默认为输入张量的最后一维。 输出形状与输入相同，除了给定维度上为1\.

_注意_: 这个函数还没有在`torch.cuda.Tensor`中定义

参数：

*   input (Tensor) – 输入张量
*   dim (int) – 缩减的维度
*   values (Tensor, 可选的) – 结果张量
*   indices (Tensor, 可选的) – 返回的索引结果张量

```py
>>> a

 -0.6891 -0.6662
 0.2697  0.7412
 0.5254 -0.7402
 0.5528 -0.2399
[torch.FloatTensor of size 4x2]

>>> a = torch.randn(4, 5)
>>> a

 0.4056 -0.3372  1.0973 -2.4884  0.4334
 2.1336  0.3841  0.1404 -0.1821 -0.7646
-0.2403  1.3975 -2.0068  0.1298  0.0212
-1.5371 -0.7257 -0.4871 -0.2359 -1.1724
[torch.FloatTensor of size 4x5]

>>> torch.median(a, 1)
(
 0.4056
 0.1404
 0.0212
-0.7257
[torch.FloatTensor of size 4x1]
,
 0
 2
 4
 1
[torch.LongTensor of size 4x1]
)
```

### torch.mode

```py
torch.mode(input, dim=-1, values=None, indices=None) -> (Tensor, LongTensor)
```

返回给定维`dim`上，每行的众数值。 同时返回一个`LongTensor`，包含众数职的索引。`dim`值默认为输入张量的最后一维。

输出形状与输入相同，除了给定维度上为1\.

_注意_: 这个函数还没有在`torch.cuda.Tensor`中定义

参数：

*   input (Tensor) – 输入张量
*   dim (int) – 缩减的维度
*   values (Tensor, 可选的) – 结果张量
*   indices (Tensor, 可选的) – 返回的索引张量

例子：

```py
>>> a

 -0.6891 -0.6662
 0.2697  0.7412
 0.5254 -0.7402
 0.5528 -0.2399
[torch.FloatTensor of size 4x2]

>>> a = torch.randn(4, 5)
>>> a

 0.4056 -0.3372  1.0973 -2.4884  0.4334
 2.1336  0.3841  0.1404 -0.1821 -0.7646
-0.2403  1.3975 -2.0068  0.1298  0.0212
-1.5371 -0.7257 -0.4871 -0.2359 -1.1724
[torch.FloatTensor of size 4x5]

>>> torch.mode(a, 1)
(
-2.4884
-0.7646
-2.0068
-1.5371
[torch.FloatTensor of size 4x1]
,
 3
 4
 2
 0
[torch.LongTensor of size 4x1]
)
```

### torch.norm

```py
torch.norm(input, p=2) → float
```

返回输入张量`input` 的p 范数。

参数：

*   input (Tensor) – 输入张量
*   p (float,可选的) – 范数计算中的幂指数值

例子：

```py
>>> a = torch.randn(1, 3)
>>> a

-0.4376 -0.5328  0.9547
[torch.FloatTensor of size 1x3]

>>> torch.norm(a, 3)
1.0338925067372466
```

```py
torch.norm(input, p, dim, out=None) → Tensor
```

返回输入张量给定维`dim` 上每行的p 范数。 输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量
*   p (float) – 范数计算中的幂指数值
*   dim (int) – 缩减的维度
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(4, 2)
>>> a

-0.6891 -0.6662
 0.2697  0.7412
 0.5254 -0.7402
 0.5528 -0.2399
[torch.FloatTensor of size 4x2]

>>> torch.norm(a, 2, 1)

 0.9585
 0.7888
 0.9077
 0.6026
[torch.FloatTensor of size 4x1]

>>> torch.norm(a, 0, 1)

 2
 2
 2
 2
[torch.FloatTensor of size 4x1]
```

### torch.prod

```py
torch.prod(input) → float
```

返回输入张量`input` 所有元素的积。

参数：input (Tensor) – 输入张量

例子：

```py
>>> a = torch.randn(1, 3)
>>> a

 0.6170  0.3546  0.0253
[torch.FloatTensor of size 1x3]

>>> torch.prod(a)
0.005537458061418483
```

```py
torch.prod(input, dim, out=None) → Tensor
```

返回输入张量给定维度上每行的积。 输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量
*   dim (int) – 缩减的维度
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(4, 2)
>>> a

 0.1598 -0.6884
-0.1831 -0.4412
-0.9925 -0.6244
-0.2416 -0.8080
[torch.FloatTensor of size 4x2]

>>> torch.prod(a, 1)

-0.1100
 0.0808
 0.6197
 0.1952
[torch.FloatTensor of size 4x1]
```

### torch.std

```py
torch.std(input) → float
```

返回输入张量`input` 所有元素的标准差。

参数：- input (Tensor) – 输入张量

例子：

```py
>>> a = torch.randn(1, 3)
>>> a

-1.3063  1.4182 -0.3061
[torch.FloatTensor of size 1x3]

>>> torch.std(a)
1.3782334731508061
```

```py
torch.std(input, dim, out=None) → Tensor
```

返回输入张量给定维度上每行的标准差。 输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量
*   dim (int) – 缩减的维度
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(4, 4)
>>> a

 0.1889 -2.4856  0.0043  1.8169
-0.7701 -0.4682 -2.2410  0.4098
 0.1919 -1.1856 -1.0361  0.9085
 0.0173  1.0662  0.2143 -0.5576
[torch.FloatTensor of size 4x4]

>>> torch.std(a, dim=1)

 1.7756
 1.1025
 1.0045
 0.6725
[torch.FloatTensor of size 4x1]
```

### torch.sum

```py
torch.sum(input) → float
```

返回输入张量`input` 所有元素的和。

输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量

例子：

```py
>>> a = torch.randn(1, 3)
>>> a

 0.6170  0.3546  0.0253
[torch.FloatTensor of size 1x3]

>>> torch.sum(a)
0.9969287421554327
```

```py
torch.sum(input, dim, out=None) → Tensor
```

返回输入张量给定维度上每行的和。 输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量
*   dim (int) – 缩减的维度
*   out (Tensor, 可选的) – 结果张量

例子：

```py
>>> a = torch.randn(4, 4)
>>> a

-0.4640  0.0609  0.1122  0.4784
-1.3063  1.6443  0.4714 -0.7396
-1.3561 -0.1959  1.0609 -1.9855
 2.6833  0.5746 -0.5709 -0.4430
[torch.FloatTensor of size 4x4]

>>> torch.sum(a, 1)

 0.1874
 0.0698
-2.4767
 2.2440
[torch.FloatTensor of size 4x1]
```

### torch.var

```py
torch.var(input) → float
```

返回输入张量所有元素的方差

输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量

例子：

```py
>>> a = torch.randn(1, 3)
>>> a

-1.3063  1.4182 -0.3061
[torch.FloatTensor of size 1x3]

>>> torch.var(a)
1.899527506513334
```

```py
torch.var(input, dim, out=None) → Tensor
```

返回输入张量给定维度上每行的方差。 输出形状与输入相同，除了给定维度上为1\.

参数：

*   input (Tensor) – 输入张量
*   dim (int) – the dimension to reduce
*   out (Tensor, 可选的) – 结果张量 例子：

    ```py
     &gt;&gt;&gt; a = torch.randn(4, 4)
    &gt;&gt;&gt; a
    ```

-1.2738 -0.3058 0.1230 -1.9615 0.8771 -0.5430 -0.9233 0.9879 1.4107 0.0317 -0.6823 0.2255 -1.3854 0.4953 -0.2160 0.2435 [torch.FloatTensor of size 4x4]

> &gt; &gt; torch.var(a, 1)

0.8859 0.9509 0.7548 0.6949 [torch.FloatTensor of size 4x1]

```py
 ## 比较操作 Comparison Ops

### torch.eq
```python 
torch.eq(input, other, out=None) → Tensor
```py

比较元素相等性。第二个参数可为一个数或与第一个参数同类型形状的张量。

参数：

*   input (Tensor) – 待比较张量
*   other (Tensor or float) – 比较张量或数
*   out (Tensor, 可选的) – 输出张量，须为 ByteTensor类型 or 与`input`同类型

返回值： 一个 `torch.ByteTensor` 张量，包含了每个位置的比较结果(相等为1，不等为0 )

返回类型： Tensor

例子：

```
>>> torch.eq(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))
1  0
0  1
[torch.ByteTensor of size 2x2]
```py

### torch.equal

```
torch.equal(tensor1, tensor2) → bool
```py

如果两个张量有相同的形状和元素值，则返回`True` ，否则 `False`。

例子：

```
>>> torch.equal(torch.Tensor([1, 2]), torch.Tensor([1, 2]))
True
```py

### torch.ge

```
torch.ge(input, other, out=None) → Tensor
```py

逐元素比较`input`和`other`，即是否 \( input &gt;= other \)。

如果两个张量有相同的形状和元素值，则返回`True` ，否则 `False`。 第二个参数可以为一个数或与第一个参数相同形状和类型的张量

参数:

*   input (Tensor) – 待对比的张量
*   other (Tensor or float) – 对比的张量或`float`值
*   out (Tensor, 可选的) – 输出张量。必须为`ByteTensor`或者与第一个参数`tensor`相同类型。

返回值： 一个 `torch.ByteTensor` 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor

例子：

```
>>> torch.ge(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))
 1  1
 0  1
[torch.ByteTensor of size 2x2]
```py

### torch.gt

```
torch.gt(input, other, out=None) → Tensor
```py

逐元素比较`input`和`other` ， 即是否\( input &gt; other \) 如果两个张量有相同的形状和元素值，则返回`True` ，否则 `False`。 第二个参数可以为一个数或与第一个参数相同形状和类型的张量

参数:

*   input (Tensor) – 要对比的张量
*   other (Tensor or float) – 要对比的张量或`float`值
*   out (Tensor, 可选的) – 输出张量。必须为`ByteTensor`或者与第一个参数`tensor`相同类型。

返回值： 一个 `torch.ByteTensor` 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor

例子：

```
>>> torch.gt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))
 0  1
 0  0
[torch.ByteTensor of size 2x2]
```py

### torch.kthvalue

```
torch.kthvalue(input, k, dim=None, out=None) -> (Tensor, LongTensor)
```py

取输入张量`input`指定维上第k 个最小值。如果不指定`dim`，则默认为`input`的最后一维。

返回一个元组 _(values,indices)_，其中`indices`是原始输入张量`input`中沿`dim`维的第 `k` 个最小值下标。

参数:

*   input (Tensor) – 要对比的张量
*   k (int) – 第 `k` 个最小值
*   dim (int, 可选的) – 沿着此维进行排序
*   out (tuple, 可选的) – 输出元组 (Tensor, LongTensor) 可选地给定作为 输出 buffers

例子：

```
>>> x = torch.arange(1, 6)
>>> x

 1
 2
 3
 4
 5
[torch.FloatTensor of size 5]

>>> torch.kthvalue(x, 4)
(
 4
[torch.FloatTensor of size 1]
,
 3
[torch.LongTensor of size 1]
)
```py

### torch.le

```
torch.le(input, other, out=None) → Tensor
```py

逐元素比较`input`和`other` ， 即是否\( input &lt;= other \) 第二个参数可以为一个数或与第一个参数相同形状和类型的张量

参数:

*   input (Tensor) – 要对比的张量
*   other (Tensor or float ) – 对比的张量或`float`值
*   out (Tensor, 可选的) – 输出张量。必须为`ByteTensor`或者与第一个参数`tensor`相同类型。

返回值： 一个 `torch.ByteTensor` 张量，包含了每个位置的比较结果(是否 input &gt;= other )。 返回类型： Tensor

例子：

```
>>> torch.le(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))
 1  0
 1  1
[torch.ByteTensor of size 2x2]
```py

### torch.lt

```
torch.lt(input, other, out=None) → Tensor
```py

逐元素比较`input`和`other` ， 即是否 \( input &lt; other \)

第二个参数可以为一个数或与第一个参数相同形状和类型的张量

参数:

*   input (Tensor) – 要对比的张量
*   other (Tensor or float ) – 对比的张量或`float`值
*   out (Tensor, 可选的) – 输出张量。必须为`ByteTensor`或者与第一个参数`tensor`相同类型。

input： 一个 `torch.ByteTensor` 张量，包含了每个位置的比较结果(是否 tensor &gt;= other )。 返回类型： Tensor

例子：

```
>>> torch.lt(torch.Tensor([[1, 2], [3, 4]]), torch.Tensor([[1, 1], [4, 4]]))
 0  0
 1  0
[torch.ByteTensor of size 2x2]
```py

### torch.max

```
torch.max()
```py

返回输入张量所有元素的最大值。

参数:

*   input (Tensor) – 输入张量

例子：

```
>>> a = torch.randn(1, 3)
>>> a

 0.4729 -0.2266 -0.2085
[torch.FloatTensor of size 1x3]

>>> torch.max(a)
0.4729
```py

```
torch.max(input, dim, max=None, max_indices=None) -> (Tensor, LongTensor)
```py

返回输入张量给定维度上每行的最大值，并同时返回每个最大值的位置索引。

输出形状中，将`dim`维设定为1，其它与输入形状保持一致。

参数:

*   input (Tensor) – 输入张量
*   dim (int) – 指定的维度
*   max (Tensor, 可选的) – 结果张量，包含给定维度上的最大值
*   max_indices (LongTensor, 可选的) – 结果张量，包含给定维度上每个最大值的位置索引

例子：

```
>> a = torch.randn(4, 4)
>> a

0.0692  0.3142  1.2513 -0.5428
0.9288  0.8552 -0.2073  0.6409
1.0695 -0.0101 -2.4507 -1.2230
0.7426 -0.7666  0.4862 -0.6628
torch.FloatTensor of size 4x4]

>>> torch.max(a, 1)
(
 1.2513
 0.9288
 1.0695
 0.7426
[torch.FloatTensor of size 4x1]
,
 2
 0
 0
 0
[torch.LongTensor of size 4x1]
)
```py

```
torch.max(input, other, out=None) → Tensor
```py

返回输入张量给定维度上每行的最大值，并同时返回每个最大值的位置索引。 即，\( out_i=max(input_i,other_i) \)

输出形状中，将`dim`维设定为1，其它与输入形状保持一致。

参数:

*   input (Tensor) – 输入张量
*   other (Tensor) – 输出张量
*   out (Tensor, 可选的) – 结果张量

例子：

```
>>> a = torch.randn(4)
>>> a

 1.3869
 0.3912
-0.8634
-0.5468
[torch.FloatTensor of size 4]

>>> b = torch.randn(4)
>>> b

 1.0067
-0.8010
 0.6258
 0.3627
[torch.FloatTensor of size 4]

>>> torch.max(a, b)

 1.3869
 0.3912
 0.6258
 0.3627
[torch.FloatTensor of size 4]
```py

### torch.min

```
torch.min(input) → float
```py

返回输入张量所有元素的最小值。

参数: input (Tensor) – 输入张量

例子：

```
>>> a = torch.randn(1, 3)
>>> a

 0.4729 -0.2266 -0.2085
[torch.FloatTensor of size 1x3]

>>> torch.min(a)
-0.22663167119026184
```py

```
torch.min(input, dim, min=None, min_indices=None) -> (Tensor, LongTensor)
```py

返回输入张量给定维度上每行的最小值，并同时返回每个最小值的位置索引。

输出形状中，将`dim`维设定为1，其它与输入形状保持一致。

参数:

*   input (Tensor) – 输入张量
*   dim (int) – 指定的维度
*   min (Tensor, 可选的) – 结果张量，包含给定维度上的最小值
*   min_indices (LongTensor, 可选的) – 结果张量，包含给定维度上每个最小值的位置索引

例子：

```
 >> a = torch.randn(4, 4)
>> a

0.0692  0.3142  1.2513 -0.5428
0.9288  0.8552 -0.2073  0.6409
1.0695 -0.0101 -2.4507 -1.2230
0.7426 -0.7666  0.4862 -0.6628
torch.FloatTensor of size 4x4]

>> torch.min(a, 1)

0.54

### 译者署名

| 用户名 | 头像 | 职能 | 签名 |
|---|---|---|---|
| [Song](https://ptorch.com)  | <img style="width:50px;height:50px;margin:10px;" src="img/2018033000352689884.jpeg">  |  翻译  | 人生总要追求点什么 |
```

